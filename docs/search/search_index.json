{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WinRAR Key File Generator. Generator The introduction and usage are at the bottom of this page. Register Name: License Type: Generate! License: but.onclick = function () { let _a = USERNAME.value; let _b = LICENSETYPE.value; KEY.value = Winrar_KeyGen(_a, _b); } Introduction WinRAR is a trialware file archiver utility for Windows, developed by Eugene Roshal of win.rar GmbH. WinRAR is not a free software. If you want to use it, you should go to RARLAB and order it. The generator is only for personal research (such as finite field arithmetic, elliptic curve cryptography) use and implemented purely in JavaScript and doesn't use any other libraries. This website only tell you how WinRAR license file \"rarreg.key\" is generated. It's forbidden to use this for business purpose. If you want to know the algorithm, you can see here (Thanks For bitcookies ). But this artical does not describe the arithmetic on the Galois Field GF(2 n ) and GF((2 n ) m ), and I describe the arithmetic here . This artical also doesn't describe the arithmetic of Elliptic Curve, and I describe the arithmetic here . Usage To generate the license please : Fill in the two blanks ( Register Name , License Type ), Click the Generate button and wait for 2-15 seconds, Save the License in ANSI encoding format as rarreg.key, Copy the file to the installation directory of WinRAR. N.B. : Save the License in ANSI encoding format, Please use ASCII characters ONLY , otherwise registration may fail, Please click the Generate button and wait for 2-15 seconds, The First line of license files is \"RAR registration data\". Some License Type : Single PC usage license Local Site License Unlimited Company License 1000 PC usage license","title":"WinRAR Key File Generator."},{"location":"#winrar-key-file-generator","text":"","title":"WinRAR Key File Generator."},{"location":"#generator","text":"The introduction and usage are at the bottom of this page. Register Name: License Type: Generate! License: but.onclick = function () { let _a = USERNAME.value; let _b = LICENSETYPE.value; KEY.value = Winrar_KeyGen(_a, _b); }","title":"Generator"},{"location":"#introduction","text":"WinRAR is a trialware file archiver utility for Windows, developed by Eugene Roshal of win.rar GmbH. WinRAR is not a free software. If you want to use it, you should go to RARLAB and order it. The generator is only for personal research (such as finite field arithmetic, elliptic curve cryptography) use and implemented purely in JavaScript and doesn't use any other libraries. This website only tell you how WinRAR license file \"rarreg.key\" is generated. It's forbidden to use this for business purpose. If you want to know the algorithm, you can see here (Thanks For bitcookies ). But this artical does not describe the arithmetic on the Galois Field GF(2 n ) and GF((2 n ) m ), and I describe the arithmetic here . This artical also doesn't describe the arithmetic of Elliptic Curve, and I describe the arithmetic here .","title":"Introduction"},{"location":"#usage","text":"To generate the license please : Fill in the two blanks ( Register Name , License Type ), Click the Generate button and wait for 2-15 seconds, Save the License in ANSI encoding format as rarreg.key, Copy the file to the installation directory of WinRAR. N.B. : Save the License in ANSI encoding format, Please use ASCII characters ONLY , otherwise registration may fail, Please click the Generate button and wait for 2-15 seconds, The First line of license files is \"RAR registration data\". Some License Type : Single PC usage license Local Site License Unlimited Company License 1000 PC usage license","title":"Usage"},{"location":"EC/","text":"Elliptic Curve Point Addition For y^2 + xy = x^3 + a x^2 + b. 1. Compute NEWP = P + P (Double P, P \u2260 O) Let m = P.X + P.Y / P.X Let New.X = m * m + m + a Let New.Y = X * X + (m + 1) * New.X 2. Compute NEWP = P + Q (P \u2260 Q, P \u2260 O, Q \u2260 O) Let m = (P.Y + Q.Y) / (P.X + Q.X) Let New.X = m * m* + m + P.X + Q.X + a Let New.Y = m * (P.X + New.X) + New.X + P.Y 3. Compute NEWP = P + O Let NEWP = P","title":"Elliptic Curve Point Addition For y^2 + xy = x^3 + a x^2 + b."},{"location":"EC/#elliptic-curve-point-addition-for-y2-xy-x3-a-x2-b","text":"","title":"Elliptic Curve Point Addition For y^2 + xy = x^3 + a x^2 + b."},{"location":"EC/#1-compute-newp-p-p-double-p-p-o","text":"Let m = P.X + P.Y / P.X Let New.X = m * m + m + a Let New.Y = X * X + (m + 1) * New.X","title":"1. Compute NEWP = P + P (Double P, P \u2260 O)"},{"location":"EC/#2-compute-newp-p-q-p-q-p-o-q-o","text":"Let m = (P.Y + Q.Y) / (P.X + Q.X) Let New.X = m * m* + m + P.X + Q.X + a Let New.Y = m * (P.X + New.X) + New.X + P.Y","title":"2. Compute NEWP = P + Q (P \u2260 Q, P \u2260 O, Q \u2260 O)"},{"location":"EC/#3-compute-newp-p-o","text":"Let NEWP = P","title":"3. Compute NEWP = P + O"},{"location":"GF/","text":"Arithmetic on the Galois Field GF(2 n ) and GF((2 n ) m ). WinRAR uses the EC signature algorithm to generate license. The Curve is over the Composite Field GF((2 15 ) 17 ). 1. GF(2) Arithmetic The finite field with p n elements is denoted GF(p n ) (p is a prime or a power of prime number). If p is a prime number then elements in GF(p) can be represented by the numbers 0, 1, ... , (p - 1). Elements that is in GF(p) can perform operations (addition, subtraction, multiplication) using the usual operation on integers, followed by reduction modulo p, and divisoin is multiplication by the inverse modulo p. In particular, for a, b \u2208 GF(2): a + b = a + b (mod 2) = a XOR b; \u2003\u2003 a * b = a * b (mod 2) = a AND b. 2. GF(2 n ) Arithmetic Elements of GF(p n ) (p is a prime or a power of prime number) can be represented as polynomials of degree strictly less than n over GF(p). Operations are then performed modulo R where R is an irreducible polynomial of degree n over GF(p). Thus, for elements a, b in GF(p n ) can be represented by the polynomials: a = \u03bb n-1 x n-1 + \u03bb n-2 x n-2 + ... + \u03bb 1 x + \u03bb 0 (\u03bb i \u2208 GF(p)), b = \u03bc n-1 x n-1 + \u03bc n-2 x n-2 + ... + \u03bc 1 x + \u03bc 0 (\u03bc i \u2208 GF(p)). And, a + b = (\u03bb n-1 + \u03bc n-1 ) x n-1 + ... + (\u03bb 0 + \u03bc 0 ), a - b = (\u03bb n-1 - \u03bc n-1 ) x n-1 + ... + (\u03bb 0 - \u03bc 0 ), a x b = (\u03bb n-1 x n-1 + \u03bb n-2 x n-2 + ... + \u03bb 1 x + \u03bb 0 )(\u03bc n-1 x n-1 + \u03bc n-2 x n-2 + ... + \u03bc 1 x + \u03bc 0 ) mod R, a / b = a x (b -1 ), b -1 is satisfied that b x (b -1 ) = 1. It is conventional to express elements of GF(2 n ) and the irreducible polynomial as n and n+1 bit numbers, with the coefficient of each term in a polynomial represented by one bit in the corresponding element's binary expression. For example: a = x 6 + x 4 + x + 1 \u2208 GF(2 8 ) Can be expressed as 0b01010011 or 0x53. Irreducible polynomial R = x 8 + x 4 + x 3 + x + 1 Can be expressed as 0b100011011 or 0x11B. So, for a, b \u2208 GF(2 n ): a + b = a - b = a BITXOR b. And a x b can be computed by this python programme: def mul(a, b, n, ir_poly): \"\"\" Input: a, b in GF(2^n). And irreducible polynomial ir_poly. Output: a x b \"\"\" mask = 2**n - 1 res = 0 while ((a != 0) and (b != 0)): if b & 1: res ^= a if a & (1<<(n-1)): a = (a << 1) ^ ir_poly else: a <<= 1 b >>= 1 res = res & mask return res To compute b -1 , you need to create the exponent table (exp_tab) and logarithm table (log_tab). You can use this python programme: def table(n, ir_poly): \"\"\" Input: GF(2^n). And irreducible polynomial ir_poly. Output: exp_tab, log_tab \"\"\" exp_tab = [] log_tab = [0]*(2 ** n) generator = 0 while len(set(exp_tab)) != ((2 ** n) - 1): exp_tab.clear() exp_tab.append(1) generator += 1 for i in range(1, 2 ** n): exp_tab.append(mul(exp_tab[i-1], generator, n, ir_poly)) for i in range(0, 2 ** n): log_tab[exp_tab[i]] = i return exp_tab, log_tab Then b -1 \u2260 0 \u2208 GF(2 n ), can be computed with this python programme: def inv(a, n, exp_tab, log_tab): \"\"\" Input: a in GF(2^n), exp_tab, log_tab Output: a^(-1) \"\"\" if a >= (2 ** n): raise Exception(\"not in this Galois Field\") if a == 0: raise Exception(\"div zero\") return exp_tab[ (((2 ** n) -1) - log_tab[a]) % ((2 ** n) -1)] 3. GF((2 n ) m ) Arithmetic GF((2 n ) m ) is the special kind of GF(p m ) (p = 2 n ). So elements in GF((2 n ) m ) can be represented as polynomials of degree strictly less than m over GF(2 n ). And the four arithmetic operations in GF(2 n ) have been described in the section 2. An element a in GF((2 n ) m ) can be expressed as an array {a_0, a_1, ... , a_(m - 1)}, and a_i \u2208 GF(2 n ). The irreducible polynomial can be expressed as an array {a_0, a_1, ... , a_m}, and a_i \u2208 GF(2 n ). So + and - over GF((2 n ) m ) can be computed by this python programme: def add(a, b): \"\"\" GF2_n_add is a function that computers + over GF(2^n) \"\"\" return [GF2_n_add(i[0],i[1]) for i in zip(a, b)] def sub(a, b): \"\"\" GF2_n_sub is a function that computers - over GF(2^n) \"\"\" return [GF2_n_sub(i[0],i[1]) for i in zip(a, b)] And multiplication over GF((2 n ) m ) can be computed by this python programme: def mul(a, b, m, ir_poly): \"\"\" GF2_n_add is a function that computers + over GF(2^n) GF2_n_sub is a function that computers - over GF(2^n) GF2_n_mul is a function that computers x over GF(2^n) GF2_n_div is a function that computers / over GF(2^n) \"\"\" if len(a) != m: raise Exception(\"a is not in this Galois Field\") if len(b) != m: raise Exception(\"b is not in this Galois Field\") if set(a) == {0}: return [0]*m if set(b) == {0}: return [0]*m _a = a.copy() _b = b.copy() res = [0]*(2*m) for i in range(0,m): for j in range(0,m): temp1 = GF2_n_mul(_a[i], _b[j]) res[i + j] = GF2_n_add(res[i + j], temp1) for i in range(2*m-1,m-1,-1): if res[i] != 0: for j in range(0,m + 1): res[i - m + j] = GF2_n_sub(res[i - m + j], GF2_n_mul(res[i], GF2_n_div(ir_poly[j], ir_poly[m]))) return res[:m] The divisoin over GF((2 n ) m ) can be computed by this python programme, use Itoh\u2013Tsujii inversion algorithm : def GF_inv(a, m, n, ir_poly): \"\"\" GF2_n_add is a function that computers + over GF(2^n) GF2_n_sub is a function that computers - over GF(2^n) GF2_n_mul is a function that computers x over GF(2^n) GF2_n_div is a function that computers / over GF(2^n) \"\"\" if set(a) == {0}: raise Exception(\"div zero\") else: base = a.copy() for r in range(0,m-1): for rr in range(0,n): base = mul(base, base, m, ir_poly) ans = mul(ans, base, m, ir_poly) temp = mul(ans, a, m, ir_poly) temp[0] = GF2_n_div(0x1, temp[0]) ans = mul(ans, temp, m, ir_poly) return ans","title":"Arithmetic on the Galois Field GF(2<sup>n</sup>) and GF((2<sup>n</sup>)<sup>m</sup>)."},{"location":"GF/#arithmetic-on-the-galois-field-gf2n-and-gf2nm","text":"WinRAR uses the EC signature algorithm to generate license. The Curve is over the Composite Field GF((2 15 ) 17 ).","title":"Arithmetic on the Galois Field GF(2n) and GF((2n)m)."},{"location":"GF/#1-gf2-arithmetic","text":"The finite field with p n elements is denoted GF(p n ) (p is a prime or a power of prime number). If p is a prime number then elements in GF(p) can be represented by the numbers 0, 1, ... , (p - 1). Elements that is in GF(p) can perform operations (addition, subtraction, multiplication) using the usual operation on integers, followed by reduction modulo p, and divisoin is multiplication by the inverse modulo p. In particular, for a, b \u2208 GF(2): a + b = a + b (mod 2) = a XOR b; \u2003\u2003 a * b = a * b (mod 2) = a AND b.","title":"1. GF(2) Arithmetic"},{"location":"GF/#2-gf2n-arithmetic","text":"Elements of GF(p n ) (p is a prime or a power of prime number) can be represented as polynomials of degree strictly less than n over GF(p). Operations are then performed modulo R where R is an irreducible polynomial of degree n over GF(p). Thus, for elements a, b in GF(p n ) can be represented by the polynomials: a = \u03bb n-1 x n-1 + \u03bb n-2 x n-2 + ... + \u03bb 1 x + \u03bb 0 (\u03bb i \u2208 GF(p)), b = \u03bc n-1 x n-1 + \u03bc n-2 x n-2 + ... + \u03bc 1 x + \u03bc 0 (\u03bc i \u2208 GF(p)). And, a + b = (\u03bb n-1 + \u03bc n-1 ) x n-1 + ... + (\u03bb 0 + \u03bc 0 ), a - b = (\u03bb n-1 - \u03bc n-1 ) x n-1 + ... + (\u03bb 0 - \u03bc 0 ), a x b = (\u03bb n-1 x n-1 + \u03bb n-2 x n-2 + ... + \u03bb 1 x + \u03bb 0 )(\u03bc n-1 x n-1 + \u03bc n-2 x n-2 + ... + \u03bc 1 x + \u03bc 0 ) mod R, a / b = a x (b -1 ), b -1 is satisfied that b x (b -1 ) = 1. It is conventional to express elements of GF(2 n ) and the irreducible polynomial as n and n+1 bit numbers, with the coefficient of each term in a polynomial represented by one bit in the corresponding element's binary expression. For example: a = x 6 + x 4 + x + 1 \u2208 GF(2 8 ) Can be expressed as 0b01010011 or 0x53. Irreducible polynomial R = x 8 + x 4 + x 3 + x + 1 Can be expressed as 0b100011011 or 0x11B. So, for a, b \u2208 GF(2 n ): a + b = a - b = a BITXOR b. And a x b can be computed by this python programme: def mul(a, b, n, ir_poly): \"\"\" Input: a, b in GF(2^n). And irreducible polynomial ir_poly. Output: a x b \"\"\" mask = 2**n - 1 res = 0 while ((a != 0) and (b != 0)): if b & 1: res ^= a if a & (1<<(n-1)): a = (a << 1) ^ ir_poly else: a <<= 1 b >>= 1 res = res & mask return res To compute b -1 , you need to create the exponent table (exp_tab) and logarithm table (log_tab). You can use this python programme: def table(n, ir_poly): \"\"\" Input: GF(2^n). And irreducible polynomial ir_poly. Output: exp_tab, log_tab \"\"\" exp_tab = [] log_tab = [0]*(2 ** n) generator = 0 while len(set(exp_tab)) != ((2 ** n) - 1): exp_tab.clear() exp_tab.append(1) generator += 1 for i in range(1, 2 ** n): exp_tab.append(mul(exp_tab[i-1], generator, n, ir_poly)) for i in range(0, 2 ** n): log_tab[exp_tab[i]] = i return exp_tab, log_tab Then b -1 \u2260 0 \u2208 GF(2 n ), can be computed with this python programme: def inv(a, n, exp_tab, log_tab): \"\"\" Input: a in GF(2^n), exp_tab, log_tab Output: a^(-1) \"\"\" if a >= (2 ** n): raise Exception(\"not in this Galois Field\") if a == 0: raise Exception(\"div zero\") return exp_tab[ (((2 ** n) -1) - log_tab[a]) % ((2 ** n) -1)]","title":"2. GF(2n) Arithmetic"},{"location":"GF/#3-gf2nm-arithmetic","text":"GF((2 n ) m ) is the special kind of GF(p m ) (p = 2 n ). So elements in GF((2 n ) m ) can be represented as polynomials of degree strictly less than m over GF(2 n ). And the four arithmetic operations in GF(2 n ) have been described in the section 2. An element a in GF((2 n ) m ) can be expressed as an array {a_0, a_1, ... , a_(m - 1)}, and a_i \u2208 GF(2 n ). The irreducible polynomial can be expressed as an array {a_0, a_1, ... , a_m}, and a_i \u2208 GF(2 n ). So + and - over GF((2 n ) m ) can be computed by this python programme: def add(a, b): \"\"\" GF2_n_add is a function that computers + over GF(2^n) \"\"\" return [GF2_n_add(i[0],i[1]) for i in zip(a, b)] def sub(a, b): \"\"\" GF2_n_sub is a function that computers - over GF(2^n) \"\"\" return [GF2_n_sub(i[0],i[1]) for i in zip(a, b)] And multiplication over GF((2 n ) m ) can be computed by this python programme: def mul(a, b, m, ir_poly): \"\"\" GF2_n_add is a function that computers + over GF(2^n) GF2_n_sub is a function that computers - over GF(2^n) GF2_n_mul is a function that computers x over GF(2^n) GF2_n_div is a function that computers / over GF(2^n) \"\"\" if len(a) != m: raise Exception(\"a is not in this Galois Field\") if len(b) != m: raise Exception(\"b is not in this Galois Field\") if set(a) == {0}: return [0]*m if set(b) == {0}: return [0]*m _a = a.copy() _b = b.copy() res = [0]*(2*m) for i in range(0,m): for j in range(0,m): temp1 = GF2_n_mul(_a[i], _b[j]) res[i + j] = GF2_n_add(res[i + j], temp1) for i in range(2*m-1,m-1,-1): if res[i] != 0: for j in range(0,m + 1): res[i - m + j] = GF2_n_sub(res[i - m + j], GF2_n_mul(res[i], GF2_n_div(ir_poly[j], ir_poly[m]))) return res[:m] The divisoin over GF((2 n ) m ) can be computed by this python programme, use Itoh\u2013Tsujii inversion algorithm : def GF_inv(a, m, n, ir_poly): \"\"\" GF2_n_add is a function that computers + over GF(2^n) GF2_n_sub is a function that computers - over GF(2^n) GF2_n_mul is a function that computers x over GF(2^n) GF2_n_div is a function that computers / over GF(2^n) \"\"\" if set(a) == {0}: raise Exception(\"div zero\") else: base = a.copy() for r in range(0,m-1): for rr in range(0,n): base = mul(base, base, m, ir_poly) ans = mul(ans, base, m, ir_poly) temp = mul(ans, a, m, ir_poly) temp[0] = GF2_n_div(0x1, temp[0]) ans = mul(ans, temp, m, ir_poly) return ans","title":"3. GF((2n)m) Arithmetic"},{"location":"README.HOW_DOES_IT_WORK/","text":"How is \"rarreg.key\" generated? WinRAR uses an ECC-based signature algorithm to generate rarreg.key . The algorithm it used is a variant of Chinese SM2 digital signature algorithm. Different to many standard ECDSAs, the curve that WinRAR selected is a curve over composite field . 1. Composite field Elements in ground field are represented with standard basis, i.e. polynomial basis. The irreducible polynomial is where each coefficients is in . If we use as the standard basis of the ground field, an element in can be denoted as The irreducible polynomial of composite field is where each coefficients is in . If we use as the standard basis of the composite field, an element in can be denoted as For clarity, we use , which is a 255-bits-long integer to denote an element in . The map between them is 2. Elliptic curve over The equation of the elliptic curve that WinRAR uses is The base point is whose order is 3. Message hash algorithm We use to denote a message whose length is . So the SHA1 value of should be where are 5 state values when SHA1 outputs. Generally speaking, the final SHA1 value should be the join of these 5 state values while each of state values is serialized in big-endian. However, WinRAR doesn't serialize the 5 state values. Instead, it use a big integer as the hash of the input message. 4. ECC digital signature algorithm We use to denote private key, to denote public key. So there must be If we use to denote the hash of input data, WinRAR use the following algorithm to perform signing: Generate a random big integer which satisfies . Calculate where means we take X coordinate of and convert it from to a big integer. If or , go back to step 1. Calculate If , go back to step 1. Output . 5. WinRAR private key generation algorithm We use to denote input data whose length is . WinRAR use it to generate private key . We use to denote 6 32-bits-long integer. So there is Let . If , we calculate SHA1 value of . Then assign SHA1 state value to : Otherwise, when , we let Regard as counter, add itself by 1. Calculate SHA1: We takes the lowest 16 bits of and donote it as . Repeat step 4 again with 14 times. After that, we will get . Then output private key 6. The private key and public key of WinRAR Private key is This private key is generated by the algorithm describled in section 5 where the length of data is zero. Public key is 7. Generation of \"rarreg.key\" The generation of license file rarreg.key requires 2 arguments: Username, an ANSI-encoded string, without null-terminator. Denoted as License type, an ANSI-encoded string, without null-terminator. Denoted as The following is the algorithm to generate rarreg.key . Use the algorithm describled in section 5, with argument , to generate private key and public key . Then output hexlified public key string with SM2 compressed public key format. The hexlified public key is denoted as . The length of should be 64. If less, pad with '0' until the length is 64. Let be Use the algorithm describled in section 5, with argument , to generate private key and public key . Then output hexlified public key string with SM2 compressed public key format. The hexlified public key is denoted as . The length of should be 64. If less, pad with '0' until the length is 64. Let be Use the algorithm describled in section 4, with argument and private key describled section 6, to get signature . The bit length of and shall not be more than 240. Otherwise, repeat this step. Convert and to hex-integer string and , without \"0x\" prefix. If the length of or is less than 60, pad character '0' until the length is 60. Let be Let be Use the algorithm describled in section 4, with argument and private key describled section 6, to get signature . The bit length of and shall not be more than 240. Otherwise, repeat this step. Convert and to hex-integer string and , without \"0x\" prefix. If the length of or is less than 60, pad character '0' until the length is 60. Let be Calculate CRC32 value of The final checksum the complement of CRC32 value. Then convert the checksum to decimal string . If the length is less than 10, pad character '0' until the length is 10. Let be Output with format A fixed header \"RAR registration data\" , taking one line. Username, taking one line. License type, taking one line UID, taking one line, with format: Output , with 54 characters a line.","title":"How is \"rarreg.key\" generated?"},{"location":"README.HOW_DOES_IT_WORK/#how-is-rarregkey-generated","text":"WinRAR uses an ECC-based signature algorithm to generate rarreg.key . The algorithm it used is a variant of Chinese SM2 digital signature algorithm. Different to many standard ECDSAs, the curve that WinRAR selected is a curve over composite field .","title":"How is \"rarreg.key\" generated?"},{"location":"README.HOW_DOES_IT_WORK/#1-composite-field","text":"Elements in ground field are represented with standard basis, i.e. polynomial basis. The irreducible polynomial is where each coefficients is in . If we use as the standard basis of the ground field, an element in can be denoted as The irreducible polynomial of composite field is where each coefficients is in . If we use as the standard basis of the composite field, an element in can be denoted as For clarity, we use , which is a 255-bits-long integer to denote an element in . The map between them is","title":"1. Composite field"},{"location":"README.HOW_DOES_IT_WORK/#2-elliptic-curve-over","text":"The equation of the elliptic curve that WinRAR uses is The base point is whose order is","title":"2. Elliptic curve over"},{"location":"README.HOW_DOES_IT_WORK/#3-message-hash-algorithm","text":"We use to denote a message whose length is . So the SHA1 value of should be where are 5 state values when SHA1 outputs. Generally speaking, the final SHA1 value should be the join of these 5 state values while each of state values is serialized in big-endian. However, WinRAR doesn't serialize the 5 state values. Instead, it use a big integer as the hash of the input message.","title":"3. Message hash algorithm"},{"location":"README.HOW_DOES_IT_WORK/#4-ecc-digital-signature-algorithm","text":"We use to denote private key, to denote public key. So there must be If we use to denote the hash of input data, WinRAR use the following algorithm to perform signing: Generate a random big integer which satisfies . Calculate where means we take X coordinate of and convert it from to a big integer. If or , go back to step 1. Calculate If , go back to step 1. Output .","title":"4. ECC digital signature algorithm"},{"location":"README.HOW_DOES_IT_WORK/#5-winrar-private-key-generation-algorithm","text":"We use to denote input data whose length is . WinRAR use it to generate private key . We use to denote 6 32-bits-long integer. So there is Let . If , we calculate SHA1 value of . Then assign SHA1 state value to : Otherwise, when , we let Regard as counter, add itself by 1. Calculate SHA1: We takes the lowest 16 bits of and donote it as . Repeat step 4 again with 14 times. After that, we will get . Then output private key","title":"5. WinRAR private key generation algorithm"},{"location":"README.HOW_DOES_IT_WORK/#6-the-private-key-and-public-key-of-winrar","text":"Private key is This private key is generated by the algorithm describled in section 5 where the length of data is zero. Public key is","title":"6. The private key and public key of WinRAR"},{"location":"README.HOW_DOES_IT_WORK/#7-generation-of-rarregkey","text":"The generation of license file rarreg.key requires 2 arguments: Username, an ANSI-encoded string, without null-terminator. Denoted as License type, an ANSI-encoded string, without null-terminator. Denoted as The following is the algorithm to generate rarreg.key . Use the algorithm describled in section 5, with argument , to generate private key and public key . Then output hexlified public key string with SM2 compressed public key format. The hexlified public key is denoted as . The length of should be 64. If less, pad with '0' until the length is 64. Let be Use the algorithm describled in section 5, with argument , to generate private key and public key . Then output hexlified public key string with SM2 compressed public key format. The hexlified public key is denoted as . The length of should be 64. If less, pad with '0' until the length is 64. Let be Use the algorithm describled in section 4, with argument and private key describled section 6, to get signature . The bit length of and shall not be more than 240. Otherwise, repeat this step. Convert and to hex-integer string and , without \"0x\" prefix. If the length of or is less than 60, pad character '0' until the length is 60. Let be Let be Use the algorithm describled in section 4, with argument and private key describled section 6, to get signature . The bit length of and shall not be more than 240. Otherwise, repeat this step. Convert and to hex-integer string and , without \"0x\" prefix. If the length of or is less than 60, pad character '0' until the length is 60. Let be Calculate CRC32 value of The final checksum the complement of CRC32 value. Then convert the checksum to decimal string . If the length is less than 10, pad character '0' until the length is 10. Let be Output with format A fixed header \"RAR registration data\" , taking one line. Username, taking one line. License type, taking one line UID, taking one line, with format: Output , with 54 characters a line.","title":"7. Generation of \"rarreg.key\""}]}